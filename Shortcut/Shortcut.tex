\documentclass[UTF8]{ctexart}
\usepackage{}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{lmodern}

\makeatletter %使\section中的内容左对齐
\renewcommand{\section}{\@startsection{section}{1}{0mm}
  {-\baselineskip}{0.5\baselineskip}{\bf\leftline}}
\makeatother

\title{开发笔记}
\author{Ivan Lin}
\date{\today}
\begin{document}
\maketitle

\section*{Visual Studio}
\noindent Resharper插件\\
alt + o: .h和.cpp文件切换\\
alt + 鼠标: 框选模式\\
ctrl+k + ctrl+c: 注释代码\\
shift+alt+up/down: 框选模式上下\\
ctrl+alt+a: open Command Window\\
ReSharper\_Suspend/ReSharper\_Resume in Command Window: close/open ReSharper\\
lib:静态库，在编译时将库代码加入程序中；dll:动态库，编译时生成一个lib和一个dll，lib用于存放dll中相应接口的索引\\
\section*{计算机图形学}
\noindent 坐标系模拟：拇指x，食指y，中指z。左手系和右手系\\
标准化向量 = 单位向量 = 法线，$\textbf{v}_{norm} = \frac{\textbf{v}}{\textbf{\textbar v\textbar }}$\\
\textbf{a} + \textbf{b} 几何解释：\textbf{a}的头连接\textbf{b}的尾，然后从\textbf{a}的尾向\textbf{b} 的头画一个向量\\
\textbf{a} - \textbf{b} 几何解释：\textbf{a}的尾连接\textbf{b}的尾，然后从\textbf{b}的头向\textbf{a} 的头画一个向量\\
向量点乘：\textbf{a $\cdot$ b}(\textbf{ab}) = \textbf{$a_1b_1+...+a_nb_n$}, 几何解释：\textbf{a $\cdot$ b} = \textbf{\textbar a\textbar \textbar b\textbar }cos$\theta$（两向量夹角）\\
向量投影：\textbf{v}分解为平行和垂直于\textbf{n}的两个分量。\\
\[ \textbf{v}_{||} = \textbf{n}\frac{\textbf{v $\cdot$ n}}{\textbf{\textbar n\textbar }^2} \qquad \textbf{v}_{\bot} = \textbf{\textbar v\textbar } - \textbf{v}_{||}\]
向量叉乘：仅可用于3D向量，$\textbf{a}\times\textbf{b} = \begin{bmatrix} \textbf{a}_y\textbf{b}_z - \textbf{a}_z\textbf{b}_y \\ \textbf{a}_z\textbf{b}_x - \textbf{a}_x\textbf{b}_z \\ \textbf{a}_x\textbf{b}_y - \textbf{a}_y\textbf{b}_x \end{bmatrix}$，几何解释：结果向量垂直于原来两个向量，$|\textbf{a}\times\textbf{b}| = |\textbf{a}||\textbf{b}|sin\theta$\\, $|\textbf{a}\times\textbf{b}| = 0$ 表示\textbf{a}与\textbf{b}平行或有一个为\textbf{0}\\
矩阵转置： \textbf{$M^T$}, 其列由\textbf{M}的行组成，\textbf{${M^T}_{ji}$} = \textbf{$M_{ij}$}\\
\textbf{${(AB)}^T = {B^T}{A^T}$}, 可推广到字符串翻转\\
$P_{camera} = P_{object}M_{object\to world}M_{world\to camera}$\\
线性变换： F(a+b) = F(a)+F(b), F(ka) = kF(a), 则称映射F是线性的（\textbf{aM}满足此条件）\\
仿射变换： 线性变换后接平移, $v^{'} = v\textbf{M} + \textbf{b}$\\
对\textbf{aM}, 求逆变换等价于求矩阵的逆\\
矩阵行列式： $|\textbf{M}|  = \sum_{j=1}^{n}m_{ij}c_{ij} = \sum_{j=1}^{n}m_{ij}(-1)^{i+j}| \textbf{M}^{\{ij\}}|$\\
矩阵的逆: $M(M^{-1}) = M^-1M = I$, 不可逆矩阵又称奇异矩阵，奇异矩阵行列式为0\\
标准伴随矩阵：adj\textbf{M}, M的代数余子式矩阵的转置矩阵。$M^{-1} = \frac{adj\textbf{M}}{|\textbf{M}|}$\\
正交矩阵：\textbf{$MM^{T} = I$}, 旋转和镜像矩阵是正交矩阵。正交矩阵满足：矩阵的每一行都是单位向量，矩阵的所有行相互垂直。\\
Vector4, 齐次坐标。(x, y, z, w)实际代表3D中的(x/w, y/w, z/w)\\
旋转矩阵：描述一个坐标中基向量到另一个坐标基向量的转换。\\
矩阵蠕变：由于浮点数精度有限导致误差积累。\\
欧拉角：heading-pitch-bank约定。\\
万向锁：三个角度不互相独立，一旦选择正负90度为pitch角，就被限制在只能绕竖直轴旋转，失去了一个维度。\\
四元数：\\
几何图元自由度：是无歧义的描述该实体所需信息量的最小数目。\\
射线：是一个有向线段，参数形式：$x(t)=x_0+t\triangle x \quad y(t)=y_0+t\triangle y$，向量记法:$p(t)=p_0 + td$，增量向量d指定了它的长度和方向, 斜截式：$y=mx+b$\\
球和圆：球表面积$S=4\pi r^2$, 球体积$V=\frac{4}{3}\pi r^3$\\
AABB: axially aligned bounding box, 轴对齐矩形边界框, 边垂直于坐标系.使用两个坐标$P_{min}$和$P_{max}$即可表示一个AABB. 变换AABB的方法，一种是重新计算变换物体的AABB, 另一种是变换AABB的八个顶点，然后根据这几个顶点计算新的AABB.\\
OBB: oriented bounding box, 方向矩形边界框。\\
平面: 隐式定义: $\textbf{p}\cdot \textbf{n}=d$, \textbf{n}为平面法向量，垂直于平面，指向方向为平面的正方向; 三个点定义: \textbf{n}通过两个点叉乘并标准化得到，d通过\textbf{n}与其中一个点点乘得到。\\
点集的最佳平面：$\textbf{n}_x=\sum_{i=1}^{n}(z_{i}+z_{i+1})(y_{i}-y_{i+1})\qquad \textbf{n}_y=\sum_{i=1}^{n}(x_{i}+x_{i+1})(z_{i}-z_{i+1})\qquad \textbf{n}_z=\sum_{i=1}^{n}(y_{i}+y_{i+1})(x_{i}-x_{i+1})$, $d=\frac{1}{n}(\sum_{i=1}^{n}p_{i})\cdot \textbf{n}$\\
点到平面的距离: $a=\textbf{q}\cdot \textbf{n}-d$\\
三角形面积: 海伦公式: $A=\sqrt{s(s-l_1)(s-l_2)(s-l_3))}$(s为周长的一半，l为三边长); $A=\frac{||e_1\times e_2||}{2}$(e为三角形的两个边向量)。\\
凸多边形: 对于一个凸多边形，其内角和为$（n-2）180^{\circ}$，判断一个点是否在多边形内，该点与所有顶点的连线组成的角度和为$360^{\circ}$。\\
点\textbf{q}在2D隐式直线上的投影点$\textbf{q'}=\textbf{q}+(d-\textbf{q}\cdot\textbf{n})\textbf{n}$
\section*{Sublime Text 2}
\noindent ctrl+shift+up/down: move line up/down\\
ctrl+alt+up/down: block edit up/down\\
alt+shift+1/2/3/4: change layout\\
\section*{Swift}
\noindent \textbf{http://blackblake.synology.me/wordpress/?p=29}: Swift里的Optional和Unwrapping\\
\section*{PhotoShop}
\noindent alt+ctrl+c: Resize Canvas\\
alt+ctrl+shift+s: Save for web\\
ctrl+h: show canvas guides; ctrl+mouse drag ruler: add canvas guide\\
\section*{LaTeX}
\noindent \%!Mode:: "TeX:UTF-8": make WinEdt show Chinese\\
\section*{Git}
\noindent gitk file/folder: show commit with file\\
\section*{Windows}
\noindent 放大镜： ctrl+alt+d: 停靠模式; ctrl+alt+l: 窗口模式; win++: 放大; win+esc: 退出放大镜\\
alt+tab, win+tab: 切换窗口\\
win+$\uparrow \downarrow \leftarrow \rightarrow$ : 放大/还原/左置/右置窗口。\\
win+space/d:　透明化/最小化所有窗口。\\
\section*{JavaScript}
\noindent JavaScript组成: ECMAScript, DOM:针对XML文件的操作接口, BOM:浏览器对象模型，HTML5标准化\\
浮点数误差：0.1 + 0.2 = 0.300000000004，通过x10法解决\\
JS没有函数签名，所以不能重载，可通过判断输入参数(arguments, callee, caller)的个数模仿重载, 而且也没有接口继承. P.S.函数签名: 包含函数名、参数类型、类名以及空间名等\\
JS对象类型：基本类型和引用类型，不可以直接操作内存空间，操作的是对象的引用。\\
JS函数参数是值传递。\\
JS没有块级作用域，即if/for循环中的变量不会在循环结束后销毁。局部环境：function, 全局环境\\
垃圾回收机制：1. 标记清除；2. 引用计数（会有循环引用的问题）\\
引用类型不是类，类是定义同一类所有对象的变量和方法的蓝图或原型，有接口和结构。\\
推荐使用对象字面量语法定义对象，因为更有封装概念，并且可以“重载”构造函数。\\
JS的数组可以同时储存任何类型的数据，且长度动态增长。var colors = new Array(); || var colors = ["red", "green", "blue"];\\
JS的数组length是非只读的，修改该值会删除相应的元素。\\
splice函数: splice(0, 2): 删除数组中的前两项; splice(2, 0, "red", "green"): 从位置2插入"red"和"green"; splice(2, 1, "red"): 删除位置2的元素，并插入"red"\\
JS的函数实际上是Function类型的实例。\\
解释器会先读取函数声明(function sum(){};)(函数声明提升)，但函数表达式(var sum = function(){};)(又称匿名函数(Lambda))需要到相应的行才会执行。\\
this引用的是函数据以执行的环境对象。\\
不属于其他任何对象的属性和方法都属于Global对象的属性和方法，如isNaN().\\
eval()函数传入完整的JS代码。\\
代码注入：\\
对象中数据属性的四个特性:[[Configurable]] [[Enumerable]] [[Writable]] [[Value]], 使用defineProperty(obj, "propertyName")函数修改。\\
\_year表示只能通过对象方法访问的属性，需要在defineProperty(obj, "year")中定义getter和setter函数。\\
hasOwnProperty(name)只在有实例属性的时候返回true(对应的是hasPrototypeProperty(name)), "name" in obj在原型属性和实例属性都返回true。\\
JS通过原型链实现继承, 具体实现为借用构造函数+原型链的寄生组合继承。\\
闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用方式就是在函数内部创建另一个函数。闭包通过作用域链继续retain外部函数的实例，直到闭包函数结束调用或解除引用才会释放外部函数的实例。\\
\end{document}
